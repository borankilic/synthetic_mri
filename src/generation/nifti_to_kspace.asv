function nifti_to_kspace(input_dir, varargin)
%NIFTI_TO_KSPACE Convert NIfTI brain images to k-space using inverse FFT
%   Saves both magnitude and phase components of complex k-space data
%
%   NIFTI_TO_KSPACE(input_dir) processes all NIfTI files in the input
%   directory, converts them to k-space using inverse FFT, and saves them
%   in a new directory with modified naming convention.
%
%   NIFTI_TO_KSPACE(input_dir, 'param', value) allows additional parameters:
%
%   Parameters:
%       input_dir:      Input directory containing NIfTI files
%       'output_dir':   Custom output directory (optional)
%       'fft_shift':    Apply fftshift (default: true)
%       'normalize':    Normalize k-space data (default: false)
%       'verbose':      Display progress messages (default: true)
%       'save_complex': Save magnitude and phase separately (default: true)
%
%   Output files:
%       For complex k-space data:
%           - *_synthkspace_magnitude_*.nii (magnitude component)
%           - *_synthkspace_phase_*.nii (phase component)
%       For real k-space data:
%           - *_synthkspace_*.nii (real data only)

    % Parse input arguments
    p = inputParser;
    addRequired(p, 'input_dir', @ischar);
    addParameter(p, 'output_dir', '', @ischar);
    addParameter(p, 'fft_shift', true, @islogical);
    addParameter(p, 'normalize', false, @islogical);
    addParameter(p, 'verbose', true, @islogical);
    addParameter(p, 'save_complex', true, @islogical);
    parse(p, input_dir, varargin{:});
    
    fft_shift = p.Results.fft_shift;
    normalize = p.Results.normalize;
    verbose = p.Results.verbose;
    save_complex = p.Results.save_complex;
    
    % Ensure input directory exists
    if ~exist(input_dir, 'dir')
        error('Input directory does not exist: %s', input_dir);
    end
    
    % Load B0 map
    b0_dir = fullfile(input_dir, 'B0_map_unwrapped');
    b0_filepath = fullfile(b0_dir, 'B0.nii');
    if ~exist(b0_filepath, 'file')
        error('B0 map not found: %s', b0_filepath);
    end
    b0_nii = load_nii(b0_filepath);
    B0_map = double(b0_nii.img);
    
    if verbose
        fprintf('Loaded B0 map from: %s\n', b0_filepath);
        fprintf('B0 map dimensions: %s\n', mat2str(size(B0_map)));
    end
    
    % Load sensitivity maps
    smap_dir = fullfile(input_dir, 'sens_maps');
    smap_mag_files = dir(fullfile(smap_dir, '*smap_mag.nii*'));
    smap_phase_files = dir(fullfile(smap_dir, '*smap_phase.nii*'));
    
    if isempty(smap_mag_files) || isempty(smap_phase_files)
        error('Sensitivity maps not found in: %s', smap_dir);
    end
    
    % Load sensitivity maps (assuming one set of maps for all images)
    smap_mag_nii = load_nii(fullfile(smap_dir, smap_mag_files(1).name));
    smap_phase_nii = load_nii(fullfile(smap_dir, smap_phase_files(1).name));
    smap_mag = double(smap_mag_nii.img);
    smap_phase = double(smap_phase_nii.img);
    
    if verbose
        fprintf('Loaded sensitivity maps from: %s\n', smap_dir);
        fprintf('Smap dimensions: %s\n', mat2str(size(smap_mag)));
    end
    
    % Create output directory path
    if isempty(p.Results.output_dir)
        output_dir = fullfile(input_dir, 'synthetic_kspace');
    else
        output_dir = p.Results.output_dir;
    end
    
    % Create output directory if it doesn't exist
    if ~exist(output_dir, 'dir')
        mkdir(output_dir);
        if verbose
            fprintf('Created output directory: %s\n', output_dir);
        end
    end
    
    % Find all NIfTI files in input directory
    nii_files = dir(fullfile(input_dir, '*.nii'));
    
    if isempty(nii_files)
        warning('No NIfTI files found in directory: %s', input_dir);
        return;
    end
    
    if verbose
        fprintf('Found %d NIfTI files to process\n', length(nii_files));
        fprintf('Input directory:  %s\n', input_dir);
        fprintf('Output directory: %s\n', output_dir);
        fprintf('FFT shift: %s\n', mat2str(fft_shift));
        fprintf('Normalize: %s\n', mat2str(normalize));
        fprintf('Save complex: %s\n', mat2str(save_complex));
        fprintf('Processing files...\n\n');
    end
    
    % Process each NIfTI file
    success_count = 0;
    error_count = 0;
    
    for i = 1:length(nii_files)
        input_filename = nii_files(i).name;
        input_filepath = fullfile(input_dir, input_filename);
        
        try
            if verbose
                fprintf('[%d/%d] Processing: %s\n', i, length(nii_files), input_filename);
            end
            
            % Read NIfTI file
            nii_data = load_nii(input_filepath);
            image_data = double(nii_data.img);
            
            % Get image dimensions
            img_size = size(image_data);
            if verbose
                fprintf('         Image dimensions: %s\n', mat2str(img_size));
                fprintf('         Data range: [%.2f, %.2f]\n', min(image_data(:)), max(image_data(:)));
            end
            
            % Extract TE value from filename or JSON
            TE = extract_te_value(input_filepath, verbose);
            if isnan(TE)
                error('Could not extract TE value for file: %s', input_filename);
            end
            
            if verbose
                fprintf('         TE value: %.3f seconds\n', TE);
            end
            
            % Prepare dimensions for broadcasting
            [nx, ny, nz] = size(image_data);
            nc = size(smap_mag, 4);
            
            % If kspace has one more/less PE or PAR lines ( due to technical
            % details in the acquisition process) pad or discard last line
            if nx > size(smap_mag,1) 
                smap_mag = padarray(smap_mag, [1 0 0 0],'post');
                smap_phase = padarray(smap_phase, [1 0 0 0],'post');
            elseif nx < size(smap_mag,1)
                smap_mag = smap_mag(1:end-1,:,:,:);
                smap_phase = smap_phase(1:end-1,:,:,:);
            end

            if nz > size(smap_mag,3) 
                smap_mag = padarray(smap_mag, [0 0 1 0],'post');
                smap_phase = padarray(smap_phase, [0 0 1 0],'post');
            elseif nz < size(smap_mag,3)
                smap_mag = smap_mag(:,:,1:end-1,:);
                smap_phase = smap_phase(:,:,1:end-1,:);
            end


            %% CORE CALCULATION %%
            % Replicate image_data and B0_map for all coils
            image_data_rep = repmat(image_data, [1, 1, 1, nc]);
            B0_map_rep = repmat(B0_map, [1, 1, 1, nc]);
            
            % Calculate phi and mag for each coil
            phi = smap_phase - pi * B0_map_rep * TE;
            mag = image_data_rep .* smap_mag;
            
            % Create complex coil images
            coil_images = mag .* exp(1i * phi);
            
            if verbose
                fprintf('         Calculated coil images with dimensions: %s\n', mat2str(size(coil_images)));
            end
            
            % Convert to k-space using inverse FFT for each coil
            if verbose
                fprintf('         Computing FFT for all coils...\n');
            end
            tic;
            
            [kspace_data, fft_details] = convert_to_kspace(coil_images, fft_shift, normalize);
            
            fft_time = toc;
            
            if verbose
                fprintf('         FFT completed in %.2f seconds\n', fft_time);
                fprintf('         K-space is complex: %s\n', mat2str(~isreal(kspace_data)));
            end
            
            
            % Save k-space data (magnitude and phase separately if complex)
            [~, name, ~] = fileparts(input_filename);
            kspace_filename = strrep(name, 'synthim', 'synth_kspace');
            output_filepath = fullfile(output_dir, [kspace_filename '.nii']);
            save_nifti(kspace_data, output_filepath, niftiinfo(input_filepath), 'data_type', 'single');
                

            % Process JSON header if it exists
            fft_details.num_coils = nc;
            mag_filepath = replace(output_filepath,'.nii', '_mag.nii');
            phase_filepath = replace(output_filepath,'.nii','_phase.nii');
            metadata = write_comprehensive_json(mag_filepath, 'ref_nii_filepath', input_filepath, 'fft_details', fft_details,  'verbose', true);
            write_comprehensive_json(phase_filepath, 'ref_nii_filepath', input_filepath, 'fft_details', fft_details, 'verbose', true);
            
            success_count = success_count + 1;
            if verbose
                fprintf('\n');
            end
            
        catch ME
            error_count = error_count + 1;
            if verbose
                fprintf('         âœ— Error processing file: %s\n', ME.message);
                fprintf('\n');
            end
        end
    end
    
    % Summary
    if verbose
        fprintf('Processing complete!\n');
        fprintf('Successfully processed: %d files\n', success_count);
        fprintf('Errors encountered: %d files\n', error_count);
        fprintf('Output directory: %s\n', output_dir);
    end
end

function TE = extract_te_value(input_filepath, verbose)
    % Extract TE value from filename or JSON file
    TE = NaN;
    
    % First try to extract from filename
    [filepath, name, ~] = fileparts(input_filepath);
    
    % Look for TE pattern in filename (e.g., TE30, te_30, TE_30ms)
    te_pattern = '(?i)te[_-]?(\d+(?:\.\d+)?)';
    tokens = regexp(name, te_pattern, 'tokens');
    
    if ~isempty(tokens)
        TE = str2double(tokens{1}{1}) / 1000; % Convert from ms to seconds
        if verbose
            fprintf('         Extracted TE from filename: %.3f ms\n', TE*1000);
        end
        return;
    end
    
    % If not found in filename, look for corresponding JSON file
    json_filepath = strrep(input_filepath, '.nii', '.json');
    if exist(json_filepath, 'file')
        try
            json_text = fileread(json_filepath);
            json_data = jsondecode(json_text);
            
            % Look for TE or echo_time fields
            if isfield(json_data, 'TE')
                TE = json_data.TE / 1000; % Convert from ms to seconds
            elseif isfield(json_data, 'echo_time')
                TE = json_data.echo_time / 1000; % Convert from ms to seconds
            elseif isfield(json_data, 'EchoTime')
                TE = json_data.EchoTime / 1000; % Convert from ms to seconds
            end
            
            if ~isnan(TE) && verbose
                fprintf('         Extracted TE from JSON: %.3f ms\n', TE*1000);
            end
        catch
            if verbose
                fprintf('         Warning: Could not parse JSON file: %s\n', json_filepath);
            end
        end
    end
    
    if isnan(TE) && verbose
        fprintf('         Warning: Could not extract TE value\n');
    end
end


% 
% function save_kspace_component(original_nii, component_data, output_filepath, verbose)
% %SAVE_KSPACE_COMPONENT Save a component of k-space data as NIfTI
% 
%     % Prepare output NIfTI structure
%     output_nii = original_nii;
%     output_nii.img = single(component_data); % Use single precision
% 
%     % Update header information
%     output_nii.hdr.dime.datatype = 16; % Single precision float
%     output_nii.hdr.dime.bitpix = 32;
% 
%     % Compute statistics
%     output_nii.hdr.dime.cal_max = max(component_data(:));
%     output_nii.hdr.dime.cal_min = min(component_data(:));
% 
%     % Save NIfTI file
%     if verbose
%         fprintf('         Writing component to file...\n');
%     end
%     tic;
%     save_nii(output_nii, output_filepath);
%     save_time = toc;
% 
%     if verbose
%         fprintf('         Component saved in %.2f seconds\n', save_time);
%     end
% end

function [kspace_data, fft_details] = convert_to_kspace(image_data, fft_shift, normalize)
%CONVERT_TO_KSPACE Convert image data to k-space using inverse FFT
    
    % Store FFT processing details
    fft_details = struct();
    fft_details.transformation = 'inverse_fft';
    fft_details.domain_from = 'image_space';
    fft_details.domain_to = 'k_space';
    fft_details.fft_shift_applied = fft_shift;
    fft_details.normalization_applied = normalize;
    fft_details.processing_timestamp = datetime(datetime('now'), 'Format', 'yyyy-MM-dd HH:mm:SS');
    
    % Handle different dimensionalities
    ndims_img = ndims(image_data);
    img_size = size(image_data);
    fft_details.image_dimensions = img_size;
    fft_details.number_of_dimensions = ndims_img;
    
    if ndims_img == 2
        % 2D image
        fft_details.fft_type = '2D_inverse_fft';
        if fft_shift
            kspace_data = fftshift(fft2(ifftshift(image_data)));
        else
            kspace_data = fft2(image_data);
        end
        
    elseif ndims_img == 3
        % 3D image
        fft_details.fft_type = '3D_inverse_fft';
        if fft_shift
            kspace_data = fftshift(fftn(ifftshift(image_data)));
        else
            kspace_data = fftn(image_data);
        end
        
    elseif ndims_img == 4
        % 4D data - apply 3D inverse FFT to spatial dimensions only
        fft_details.fft_type = '3D_inverse_fft_per_volume';
        fft_details.temporal_dimension = size(image_data, 4);
        kspace_data = zeros(size(image_data));
        for t = 1:size(image_data, 4)
            vol = image_data(:,:,:,t);
            if fft_shift
                kspace_data(:,:,:,t) = fftshift(fftn(ifftshift(vol)));
            else
                kspace_data(:,:,:,t) = fftn(vol);
            end
        end
        
    else
        error('Unsupported image dimensionality: %d', ndims_img);
    end
    
    % Apply normalization if requested
    if normalize
        kspace_data = kspace_data / sqrt(numel(kspace_data));
        fft_details.normalization_factor = 1 / sqrt(numel(kspace_data));
    end
    
    % Add k-space statistics
    fft_details.kspace_is_complex = ~isreal(kspace_data);
    if fft_details.kspace_is_complex
        fft_details.magnitude_range = [min(abs(kspace_data(:))), max(abs(kspace_data(:)))];
        fft_details.phase_range = [min(angle(kspace_data(:))), max(angle(kspace_data(:)))];
        fft_details.real_range = [min(real(kspace_data(:))), max(real(kspace_data(:)))];
        fft_details.imag_range = [min(imag(kspace_data(:))), max(imag(kspace_data(:)))];
    else
        fft_details.data_range = [min(kspace_data(:)), max(kspace_data(:))];
    end
end

% function process_json_header_enhanced(input_filepath, output_dir, fft_details, save_complex, verbose)
% %Enhanced JSON processing for complex k-space data
% 
%     [input_dir, base_name, ~] = fileparts(input_filepath);
%     json_input_filepath = fullfile(input_dir, [base_name '.json']);
% 
%     if ~exist(json_input_filepath, 'file')
%         return; % Skip if no JSON file exists
%     end
% 
%     try
%         % Read original JSON
%         json_text = fileread(json_input_filepath);
%         original_data = jsondecode(json_text);
%     catch
%         if verbose
%             fprintf('         Warning: Could not read JSON file\n');
%         end
%         return;
%     end
% 
%     % Create base enhanced data structure
%     enhanced_data = original_data;
%     enhanced_data.FourierTransform = fft_details;
%     enhanced_data.DataType = 'k-space';
%     enhanced_data.ComplexData = fft_details.kspace_is_complex;
% 
%     if fft_details.kspace_is_complex && save_complex
%         % Create separate JSON files for magnitude and phase
% 
%         % Magnitude JSON
%         mag_data = enhanced_data;
%         mag_data.Component = 'magnitude';
%         mag_data.DataRange = fft_details.magnitude_range;
%         mag_json_filename = strrep([base_name '.json'], 'synthim', 'synthkspace_magnitude');
%         write_json_file(fullfile(output_dir, mag_json_filename), mag_data);
% 
%         % Phase JSON
%         phase_data = enhanced_data;
%         phase_data.Component = 'phase';
%         phase_data.DataRange = fft_details.phase_range;
%         phase_data.Units = 'radians';
%         phase_json_filename = strrep([base_name '.json'], 'synthim', 'synthkspace_phase');
%         write_json_file(fullfile(output_dir, phase_json_filename), phase_data);
% 
%     else
%         % Single JSON file
%         if fft_details.kspace_is_complex
%             enhanced_data.Component = 'magnitude_only';
%             enhanced_data.DataRange = fft_details.magnitude_range;
%         else
%             enhanced_data.Component = 'real_data';
%             enhanced_data.DataRange = fft_details.data_range;
%         end
% 
%         output_json_filename = strrep([base_name '.json'], 'synthim', 'synthkspace');
%         write_json_file(fullfile(output_dir, output_json_filename), enhanced_data);
%     end
% 
%     if verbose
%         fprintf('         âœ“ JSON metadata updated\n');
%     end
% end
% 
% function write_json_file(filepath, data)
% %WRITE_JSON_FILE Write JSON data to file with error handling
%     try
%         json_text = jsonencode(data, 'PrettyPrint', true);
%     catch
%         json_text = jsonencode(data);
%     end
% 
%     fid = fopen(filepath, 'w');
%     if fid == -1
%         error('Cannot create JSON file: %s', filepath);
%     end
%     fprintf(fid, '%s', json_text);
%     fclose(fid);
% end
% 
% % Include the original helper functions (load_nii, save_nii) here as well
% function nii = load_nii(filename)
% %LOAD_NII Load NIfTI file using available toolbox
%     try
%         nii = load_nii(filename);
%     catch
%         try
%             V = spm_vol(filename);
%             img = spm_read_vols(V);
%             nii.hdr = V;
%             nii.img = img;
%             nii.hdr.dime.datatype = V.dt(1);
%             nii.hdr.dime.bitpix = spm_type(V.dt(1), 'bits');
%             nii.hdr.dime.cal_max = max(img(:));
%             nii.hdr.dime.cal_min = min(img(:));
%         catch
%             try
%                 img = niftiread(filename);
%                 info = niftiinfo(filename);
%                 nii.img = img;
%                 nii.hdr = info;
%             catch
%                 error('Unable to read NIfTI file. Please ensure you have NIfTI toolbox, SPM, or MATLAB R2017b+ installed.');
%             end
%         end
%     end
% end
% 
% function save_nii(nii, filename)
% %SAVE_NII Save NIfTI file using available toolbox
%     try
%         save_nii(nii, filename);
%     catch
%         try
%             V = nii.hdr;
%             V.fname = filename;
%             V.dt = [nii.hdr.dime.datatype 0];
%             spm_write_vol(V, nii.img);
%         catch
%             try
%                 niftiwrite(nii.img, filename, nii.hdr);
%             catch
%                 error('Unable to save NIfTI file. Please ensure you have NIfTI toolbox, SPM, or MATLAB R2017b+ installed.');
%             end
%         end
%     end
% end